require=function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r}()({1:[function(require,module,exports){class Agent{constructor(name){this.id=name;if(!name){this.id=Math.round(Math.random()*1e9)}this.state=null;this.perception=null;this.table={default:0}}setup(initialState={}){this.initialState=initialState}receive(inputs){this.perception=inputs}send(){return this.table["deafult"]}getLocalName(){return this.id}getID(){return this.id}stop(){}}module.exports=Agent},{}],2:[function(require,module,exports){class AgentController{constructor(){this.agents={};this.world0=null;this.actions=[];this.data={states:{},world:{}}}setup(parameter){this.problem=parameter.problem;this.world0=JSON.parse(JSON.stringify(parameter.world));this.data.world=JSON.parse(JSON.stringify(parameter.world))}register(agent,state0){if(this.agents[agent.getID()]){throw"AgentIDAlreadyExists"}else{this.agents[agent.getID()]=agent;this.data.states[agent.getID()]=state0;agent.setup(state0)}}unregister(input){let id="";if(typeof input=="string"){id=input}else if(typeof input=="object"){id=input.getID()}else{throw"InvalidAgentType"}let agent=this.agents[id];agent.stop();delete this.agents[id]}start(callbacks,interactive=false){this.callbacks=callbacks;this.currentAgentIndex=0;if(interactive===false){this.loop();return null}else{return this}}next(){if(!this.problem.goalTest(this.data)){let keys=Object.keys(this.agents);let agent=this.agents[keys[this.currentAgentIndex]];agent.receive(this.problem.perceptionForAgent(this.getData(),agent.getID()));let action=agent.send();this.actions.push({agentID:agent.getID(),action:action});this.problem.update(this.data,action,agent.getID());if(this.problem.goalTest(this.data)){this.finishAll();return false}else{if(this.callbacks.onTurn){this.callbacks.onTurn({actions:this.getActions(),data:JSON.parse(JSON.stringify(this.data))})}if(this.currentAgentIndex>=keys.length-1)this.currentAgentIndex=0;else this.currentAgentIndex++;return true}}}loop(){let stop=false;while(!stop){Object.values(this.agents).forEach(agent=>{if(!this.problem.goalTest(this.data)){agent.receive(this.problem.perceptionForAgent(this.getData(),agent.getID()));let action=agent.send();this.actions.push({agentID:agent.getID(),action:action});this.problem.update(this.data,action,agent.getID());if(this.problem.goalTest(this.data)){stop=true}else{if(this.callbacks.onTurn)this.callbacks.onTurn({actions:this.getActions(),data:this.data})}}})}this.finishAll()}finishAll(){Object.values(this.agents).forEach(agent=>{this.unregister(agent)});if(this.callbacks.onFinish)this.callbacks.onFinish({actions:this.getActions(),data:this.data})}getData(){return this.data}getActions(){return JSON.parse(JSON.stringify(this.actions))}stop(){this.finishAll()}}module.exports=AgentController},{}],3:[function(require,module,exports){const AgentController=require("../core/AgentController");class Problem{constructor(initialState){this.controller=new AgentController}goalTest(solution){}update(data,action,agentID){}perceptionForAgent(data,agentID){}addAgent(agentID,agentClass,initialState){let agent=new agentClass(agentID);this.controller.register(agent,initialState)}solve(world,callbacks){this.controller.setup({world:world,problem:this});this.controller.start(callbacks,false)}interactiveSolve(world,callbacks){this.controller.setup({world:world,problem:this});return this.controller.start(callbacks,true)}}module.exports=Problem},{"../core/AgentController":2}],4:[function(require,module,exports){const Problem=require("./core/Problem");const Agent=require("./core/Agent");const AgentController=require("./core/AgentController");module.exports={Problem:Problem,Agent:Agent,AgentController:AgentController}},{"./core/Agent":1,"./core/AgentController":2,"./core/Problem":3}],5:[function(require,module,exports){function transpose(board){let size=board.length;let boardT=new Array(size);for(let j=0;j<size;j++){boardT[j]=new Array(size);for(let i=0;i<size;i++){boardT[j][i]=board[i][j];if(boardT[j][i]==="1"){boardT[j][i]="2"}else if(boardT[j][i]==="2"){boardT[j][i]="1"}}}return boardT}module.exports=transpose},{}],"/src/HexAgentMegabor.js":[function(require,module,exports){const Agent=require("ai-agents").Agent;const transpose=require("./transposeHex");var INFINITY=Number.MAX_SAFE_INTEGER;class HexAgent extends Agent{constructor(value){super(value)}send(){var id=this.getID();let board=this.perception;let size=board.length;let available=getEmptyHex(board);let nTurn=size*size-available.length;if(nTurn==0){return[Math.floor(size/2),Math.floor(size/2)-1]}else if(nTurn==1){return[Math.floor(size/2),Math.floor(size/2)]}var auxBoard=board;if(id===2){auxBoard=transpose(board)}let move=available[Math.round(Math.random()*(available.length-1))];var alpha=-INFINITY;var beta=INFINITY;let nodes=alphabetaminimax([[0,0],alpha],[[0,0],beta],10,auxBoard,id);return nodes[0]}}module.exports=HexAgent;function getEmptyHex(board){let result=[];let size=board.length;for(let k=0;k<size;k++){for(let j=0;j<size;j++){if(board[k][j]===0){result.push([k,j])}}}return result}function isValid(newposition,board,size){let x=newposition[0];let y=newposition[1];if(x<0||x>=size||y<0||y>=size){return false}else if(board[x][y]==1||board[x][y]==2){return true}return true}function getNeighbors(position,board){let size=board.length;let result=[];let AIsValid=isValid([position[0]-1,position[1]+0],board,size);let BIsValid=isValid([position[0]-1,position[1]+1],board,size);let CIsValid=isValid([position[0]+0,position[1]-1],board,size);let DIsValid=isValid([position[0]+0,position[1]+1],board,size);let EIsValid=isValid([position[0]+1,position[1]-1],board,size);let FIsValid=isValid([position[0]+1,position[1]+0],board,size);if(AIsValid){result.push([position[0]-1,position[1]+0])}else{result.push([false,false])}if(BIsValid){result.push([position[0]-1,position[1]+1])}else{result.push([false,false])}if(CIsValid){result.push([position[0]+0,position[1]-1])}else{result.push([false,false])}if(DIsValid){result.push([position[0]+0,position[1]+1])}else{result.push([false,false])}if(EIsValid){result.push([position[0]+1,position[1]-1])}else{result.push([false,false])}if(FIsValid){result.push([position[0]+1,position[1]+0])}else{result.push([false,false])}return result}function getValidNeighbors(position,board){let size=board.length;let result=[];let AIsValid=isValid([position[0]-1,position[1]+0],board,size);let BIsValid=isValid([position[0]-1,position[1]+1],board,size);let CIsValid=isValid([position[0]+0,position[1]-1],board,size);let DIsValid=isValid([position[0]+0,position[1]+1],board,size);let EIsValid=isValid([position[0]+1,position[1]-1],board,size);let FIsValid=isValid([position[0]+1,position[1]+0],board,size);if(AIsValid){result.push(true)}else{result.push(false)}if(BIsValid){result.push(true)}else{result.push(false)}if(CIsValid){result.push(true)}else{result.push(false)}if(DIsValid){result.push(true)}else{result.push(false)}if(EIsValid){result.push(true)}else{result.push(false)}if(FIsValid){result.push(true)}else{result.push(false)}return result}function getCostoDjk(actualPosVal,player){if(actualPosVal==0){return 2}else if(actualPosVal==player){return 1}else{return INFINITY}}function setCostoDjk(actualPos,player,matrix,board){let areValidMov=getValidNeighbors(actualPos,board);let validMov=getNeighbors(actualPos,board);let matrixCopia=JSON.parse(JSON.stringify(matrix));if(matrixCopia[actualPos[0]][actualPos[1]]!=INFINITY){for(var i=0;i<areValidMov.length;i++){if(areValidMov[i]){let costo=getCostoDjk(board[validMov[i][0]][validMov[i][1]],player);if(costo==2||costo==1){let costoAcumulado=0;if(matrixCopia[actualPos[0]][actualPos[1]]==-INFINITY){continue}else{costoAcumulado=matrixCopia[actualPos[0]][actualPos[1]]+costo}if(matrixCopia[validMov[i][0]][validMov[i][1]]==-INFINITY){matrixCopia[validMov[i][0]][validMov[i][1]]=costoAcumulado}else if(matrixCopia[validMov[i][0]][validMov[i][1]]==INFINITY){continue}else if(costoAcumulado<matrixCopia[validMov[i][0]][validMov[i][1]]){matrixCopia[validMov[i][0]][validMov[i][1]]=costoAcumulado}}else{matrixCopia[validMov[i][0]][validMov[i][1]]=costo}}}}return matrixCopia}function getMatrixCostosDjk(board,matrix,player){let matrixCopia=JSON.parse(JSON.stringify(matrix));if(player==1){for(var i=0;i<board.length;i++){for(var j=0;j<board.length;j++){matrixCopia=setCostoDjk([i,j],player,matrixCopia,board)}}}else{for(var i=0;i<board.length;i++){for(var j=0;j<board.length;j++){matrixCopia=setCostoDjk([j,i],player,matrixCopia,board)}}}return matrixCopia}function testDjk(board,player){let size=board.length;let matrix=[];for(var i=0;i<size;i++){matrix[i]=[];for(var j=0;j<size;j++){matrix[i][j]=0}}if(player==1){for(var i=0;i<size;i++){matrix[i]=[];for(var j=0;j<size;j++){if(board[i][j]==player&&j==0){matrix[i][j]=0}else if(j==0){matrix[i][j]=3}else if(board[i][j]==0||board[i][j]==player){matrix[i][j]=-INFINITY}else{matrix[i][j]=INFINITY}}}}else{for(var i=0;i<size;i++){for(var j=0;j<size;j++){if(board[i][j]==player&&i==0){matrix[i][j]=0}else if(i==0){matrix[i][j]=3}else if(board[i][j]==0||board[i][j]==player){matrix[i][j]=-INFINITY}else{matrix[i][j]=INFINITY}}}}let nMatrix=getMatrixCostosDjk(board,matrix,player);for(var i=0;i<size;i++){nMatrix=getMatrixCostosDjk(board,nMatrix,player)}let path=0;if(player==1){path=findNextCheaperNeighbor(board,nMatrix,1)}else{path=findNextCheaperNeighbor(board,nMatrix,0)}let info=[path,nMatrix];return info}function include(array,value){let isEqual=false;for(var i=0;i<array.length;i++){if(array[i].length!=value.length){return isEqual}else{if(array[i][0]==value[0]&&array[i][1]==value[1]){isEqual=true}}}return isEqual}function findNextCheaperNeighbor(board,nMatrix,player){let shortestPath=[];let visitedNodes=[];let stopIterating=true;let size=board.length;let position=[];let menor=INFINITY;if(player==1){for(var i=0;i<size;i++){if(nMatrix[i][size-1]==-INFINITY){continue}else if(nMatrix[i][size-1]<=menor&&!include(visitedNodes,[i,size-1])){menor=nMatrix[i][size-1];shortestPath=[[i,size-1]];position=[i,size-1]}}}else{for(var i=0;i<size;i++){if(nMatrix[size-1][i]==-INFINITY){continue}else if(nMatrix[size-1][i]<=menor&&!include(visitedNodes,[size-1,i])){menor=nMatrix[size-1][i];shortestPath=[[size-1,i]];position=[size-1,i]}}}if(shortestPath.length==0){return[]}visitedNodes.push(position);menor=INFINITY;n=0;while(stopIterating){n=n+1;let boolNeighbors=getValidNeighbors(position,board);let neighbors=getNeighbors(position,board);for(var i=0;i<neighbors.length;i++){if(boolNeighbors[i]){if(position[player]==0||n>50){stopIterating=false}if(include(visitedNodes,neighbors[i])){continue}if(nMatrix[neighbors[i][0]][neighbors[i][1]]==-INFINITY){visitedNodes.push(neighbors[i]);continue}else if(nMatrix[neighbors[i][0]][neighbors[i][1]]>menor){visitedNodes.push(neighbors[i]);continue}else if(nMatrix[neighbors[i][0]][neighbors[i][1]]<=menor&&!include(visitedNodes,neighbors[i])){visitedNodes.push(neighbors[i]);menor=nMatrix[neighbors[i][0]][neighbors[i][1]];position=neighbors[i]}else if(include(visitedNodes,neighbors[i])){visitedNodes.push(neighbors[i])}else{visitedNodes.push(neighbors[i]);menor=nMatrix[neighbors[i][0]][neighbors[i][1]];position=neighbors[i]}}}shortestPath.push(position)}return shortestPath}function getHeuristic(value){return value}function removeAlreadyPLayed(board,path,player){var pos=[];var pathnew=path;for(var i=0;i<path.length;i++){pos=board[path[i][0]][path[i][1]];if(pos==player){pathnew.splice(i,1)}}return pathnew}function alphaBetaMax(alpha,beta,depth,board,player){info=testDjk(board,player);let path=info[0];path=removeAlreadyPLayed(board,path,player);if(depth==0){}let nMatrix=info[1];delete info;let score=[[3,3],0];if(depth==0){if(path.length==0){return[[3,3],-100]}return[path[0],-1*nMatrix[path[0][0]][path[0][1]]]}for(var i=0;i<path.length;i++){var newBoard=JSON.parse(JSON.stringify(board));if(player==1){newBoard[path[i][0]][path[i][1]]=1;score=alphaBetaMin(alpha,beta,depth-1,newBoard,2)}else{newBoard[path[i][0]][path[i][1]]=2;score=alphaBetaMin(alpha,beta,depth-1,newBoard,1)}if(score[1]>=beta[1]){if(beta[1]==INFINITY){}return[path[i],beta[1]]}if(score[1]>alpha[1]){alpha=[path[i],score[1]]}}return alpha}function alphaBetaMin(alpha,beta,depth,board,player){info=testDjk(board,player);let path=info[0];path=removeAlreadyPLayed(board,path,player);if(depth==0){}let nMatrix=info[1];delete info;let score=[[3,3],0];if(depth==0){if(path.length==0){return[[3,3],100]}var heuristic=getHeuristic(nMatrix[path[0][0]][path[0][1]]);return[path[0],heuristic]}for(var i=0;i<path.length;i++){var newBoard=JSON.parse(JSON.stringify(board));if(player==1){newBoard[path[i][0]][path[i][1]]=1;score=alphaBetaMax(alpha,beta,depth-1,newBoard,2)}else{newBoard[path[i][0]][path[i][1]]=2;score=alphaBetaMax(alpha,beta,depth-1,newBoard,1)}if(score[1]<=alpha[1]){return[path[i],alpha[1]]}if(score[1]<beta[1]){beta=[path[i],score[1]]}}return beta}function alphabetaminimax(alpha,beta,depth,board,player){if(player==1){return alphaBetaMax(alpha,beta,depth,board,player)}else if(player==2){return alphaBetaMin(alpha,beta,depth,board,player)}}},{"./transposeHex":5,"ai-agents":4}]},{},[]);
